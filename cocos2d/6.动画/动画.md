# 动画

动作(action)包括基本动作的组合,包含

- 缩放
- 移动
- 旋转

在继承Node类的对象中,有下列函数

```cpp
class Node{

//运行指定动作
Action *runAction(Action *a);

//停止动作
void stopAction(Action *action);

//通过标签停止动作
void stopActionByTag(int tag);

//停止所有动作
void stopAllAction();

};

```

## 精灵动画

精灵(Sprite)继承了动画操作的接口

### 动画系统

```cpp
//动作类接口
class Action{
    //运行动画
    Action* runAction(Action* action);
    
    //停止动画
    void stopAllActions();
    
    //运行动画的数量
    unsigned int numberOfRunningActions();
}
```



## 动作类型

`cocos2d-x`通过动作修改节点类型的一些属性,达到节点对象的动态效果

#### 瞬时动作

瞬时动作就是立即执行的动作

```cpp
//瞬时动作
class ActionInstance;	//虚基类


//改变位置
class Place;

//隐藏动作
class Hide;
//显示动作
class Show;
//镜像X
class FlipX;
//镜像Y
class FlipY;
```

每个类都通过了``create``动态创建的方式实现

#### 间隔动作

执行完成需要一定时间的动作,执行完成需要一定的时间

通过设置duration属性完成间隔动作

```cpp
//间隔动作父类方法
class ActionInterval{
 	//反动作
	void reverse();   
};

// 移动到指定的位置
class MoveTo{
	static MoveTo* create(float duration,  Vec2& deltaPosition);
};
// 移动到相对的位置
class MoveBy{
    static MoveBy* create(float duration,  Vec2& deltaPosition);
};
//跳跃到指定位置
class JumpTo;  
//跳跃到相对位置
class JumpBy;

//缩放
class ScaleBy;

//闪烁
class Blink;

//色调变化
class TintTo;
class TintBy;

//变暗
class FadeTo;
//淡出
class FadeTo;
//渐隐
class FadeOut;

```

## By 和 To 的区别

每一个动作都会有两个方法 **By** 和 **To**两个函数,，**By** 算的是相对于节点对象的当前位置,**To** 算的是绝对位置

比如:

```cpp
int a=10;
//By表示在原来位置的基础上修改
a+=5;
//to就是直接修改
a=5;
```

在程序中使用

```cpp
//从当前位置向右移动500米
MoveBy::create(20,Vec2(0,500));

MoveToLLc
```



### 时间控制



## 组合动作

### 序列动作Sequence

序列动作,可以将多个动作组合在一起,然后一个一个的执行

```cpp
class Sequence{
	static Sequence* create(Action* action,...);
};
```

使用Sequence

```cpp
//最后一个一定要用nullptr结尾,否则出现异常
Sequence::create(动画1,动画2,回调函数,nullptr);
```

### (组合动作)Spawn

同步动画,多个动画同时进行

```cpp
class Spawn{
    //调用原理同上,需要最后用nullptr结尾
    static Spawn* create(Action* action,...);
};
```

使用

```cpp
auto moveTo=MoveTo::create();
auto moveTo2=MoveTo::create();
this->runAction(Spawn::create(moveTo,moveTo2,nullptr));
```



### 反转动作(Reverse)

反动作,反向执行动作

```cpp
auto moveby=MoveBy:create(0,500);
auto moverReverse=moveby->reverse();

```



### 无限重复动作(RepteatForever)

无限重复动画,会不停的执行动画

### Animate

动画资源,使用帧动画,初始化动画图片资源

```cpp
//将资源导入到SpriteFrameCatche中
SpriteFrameCatche
```

使用帧动画

```cpp
Vector<SpriteFrame*> v;
SpriteFrame* frame_m = SpriteFrameCache::getInstance()->getSpriteFrameByName(tag);
```



### 函数调用

精灵图片纹理

```
SpriteBatchNode;
```

## 自定义扩展动画



```cpp
//函数调用,定义回调函数,可以在组合动画中使用
auto callFn = CallFunc::create([] {});
```

初始化动画图片资源

```cpp
SpriteFrameCatche  *catche=SpriteFrameCatche::create();
```

精灵图片纹理

```
SpriteBatchNode;
```

### 动画资源

```cpp
//创建数组
Vector<SpriteFrame*> v;
//导入材质
SpriteFrame* frame_m = SpriteFrameCache::getInstance()->getSpriteFrameByName(tag);
//创建精灵帧
Amimation *amimation =Animation::createWithSpriteFrame();
//创建动作
Animate *animate=Animate::create(amimation); 
this->runAction(animate);
```

### 从plist文件中导入动画资源

```cpp
auto cache=SpriteFrameCache::getInstance();
cache->addSpriteFrameWithFile("anim.plist");
Vector<SpriteFrame*> v;
for(int i=0;i<20;i++){
    string anim="amim";
    anim+=i;
    cache->getSpriteFrameByName("anim");
    v.pushBack();
}

Amimation *amimation =Animation::createWithSpriteFrame(v,0.1f);
//创建动作
Animate *animate=Animate::create(amimation); 
this->runAction(animate);
```



## 动作监听

通过调研`CallFunc`类来自定义函数监听

```cpp
auto m=MoveBy::create(Vec2(500,0));
auto sque=Sequence::create(MoveBy::create(1,Point(100,100)),CallFunc::create([](){}),nullptr); 
```



## 其他动作

```cpp
class FiniteTimeAction;

class Speed;

class Follw;
```





