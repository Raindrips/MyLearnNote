# Chipmunk物理引擎

物理引擎能够模仿真实世界的运动规律,使精灵能够做出自由落体,抛物线运动,互相碰撞,反弹等效果

使用物理引擎还可以进行碰撞检测,往往自己写的碰撞检测没有优化而效率低下

物理引擎通过刚体物体赋予物理属性来计算运动,物理引擎不一定会完全遵守`牛顿定律`,而是模拟器环境来运行

`cocos2d`常用的物理引擎的底层是`box2d`引擎和`Chipmunk`引擎

## 核心概念

1. 世界(world)游戏中的物理世界
2. 物体(body)构成物理世界的基础,具有位置,旋转角度等特性,他们上面的任何两点之间的距离是完全不变的可以称为刚体(rigid body)
3. 形状 (Sharp)物体的形状,一个二维碰撞的集合结构
4. 接触点(Contact) 管理检测碰撞
5. 关节(joint) 把两个或多个物体固定到一起的约束



+ 刚体,在运动中受力后,形状和大小不变,且内部各点相对不变的物体
+ 物体,由矩形,圆形等多种形状组成

物体分类

+ 静态物体	参与碰撞

+ 动态物体    可以碰撞,可以受力,可以移动

+ 运动学物体 不受力可以移动,可以参与运动




### 物体与精灵之间的关系

物理引擎本身不包括精灵,通常是通过程序使精灵与物理引擎进行连接

物理引擎和精灵是相互之间独立的,精灵不会自动地跟着物理引擎做物理运动,而是通过和编写代码将物体和精灵连接起来,同步他们的状态.



### cocos2d自带物理引擎

```c++
class Scene{
    //创建场景对象
    static Scene* createWithPhysics();

    //初始化具有物理引擎的的场景对象
    bool initWithPhysics();

    //增加解答到物理世界
    void addChildToPhysicsWorld(Node *child);
    
    //添加节点到物理引擎世界
    bool addchildToPhysics();
    
    //获取物理世界对象
    PhysicsWorld *getPhysicsWorld();

};
```

## 

## 物理引擎常用类

```cpp
//封装了物理世界引擎
class PhysicsWorld;

//封装物理引擎形状
class PhysiscBody;

//物理引擎碰撞
class PhysiscSharp;

//碰撞监听类
class EventListenerPhysicsContact;

//封装物理引擎关节
class PhysicsJoit;
```

### 形状类

```c++
//形状类
class PhysicsSharp{
    public:
    //画圆
    class PhysicsShapeCircle;
    //多边形
    class PhysicsShapePolygon;
    //有边的线段
    class PhysicsShapeEdgeBox;
     //有边的矩形盒子
    class PhysicsShapeEdgeBox;
    //有边的多边形
    class PhysicsShapeEdgePolygon;
};
```

### 碰撞检测事件属性

通过`EventListenerPhysicsContact` 中检测碰撞事件响应属性

```cpp
//开始接触响应事件,只调用一次
function<bool PhysicsContact& contact> onContactBegin;

//持续接触监听事件,返回false的情况下不调用onContactPostSolve
function<bool PhysicsContact& contact, PhiscsContactPreSolve &solve> onContactPreSolve;

//持续接触监听事件,调用完onContactPreSolve后调用
function<bool PhysicsContact& contact, PhiscsContactPreSolve &solve> onContactPostSolve;

//分离时响应,只调用一次
function<bool PhysicsContact& contact> onContactSeperate;
```

## 创建步骤

1. 创建物理世界
2. 创建世界边界
3. 创建物理世界物体

给物理世界添加`debug`测试

```cpp
//创建物理世界
scene=Scene::createWithPhysics();
scene->getPhysicsWorld()->setDebugDrawMask(PhysicsWorld::DEBUGDRAW_ALL);
```

创建边界框

```cpp
//边界大小
auto body=PhysicsBody::createEdgeBox(visibleSize,PHYSICSBODY_MATERIAL_DEFAULT,3);

auto shape=Node::create();
//创建物理组建
shape->setPhysicsBody(body);
shape->setPosition(origin.x+visibleSize.width,origin.y+visibleSize.height);
addChild(shape);

//创建精灵,绑定物理效果
auto sprite=Sprite::create();
//绑定物理组建
sprite->setPhysicsBody(PhysicsBody::createBox(sprite->getContentSize()));
addChild(sprite);
```

# Box2D引擎

## 核心概念

1. 世界`b2World ` 物理引擎中的物理世界
2. 物体`b2Body`,物理世界中的物体
3. 形状(`b2Shape`),物体中的形状
4. 夹具(`b2Joint`) 将形状固定在物体的装置上,有了形状才能具有碰撞等物理特性
5. 关节(`b2Fixture`) 引擎中的关节

## 使用Box2D引擎

1. 创建物理世界
2. 指定世界边界
3. 创建世界中的物体
4. 创建形状
5. 创建夹具
6. 使用夹具固定到物体上
7. 连接精灵和物体
8. 碰撞检测

## 创建box2D物理引擎

引入一个头文件

```cpp
#include "Box2D/Box2D.h"
```

创建一个世界并指定它的加速度方向

```cpp
world = new b2World(b2Vec2(0, -10));
```

创建一个运动的物体

```cpp
//定义运动的物体
b2BodyDef def;
//运动的类型
def.type = b2BodyType::b2_dynamicBody;
//运动的位置
def.position = b2Vec2(4, 5);
//创建物体
b2Body* body= world->CreateBody(&def);
```

然后让这个物体和sprite绑定在一起

```cpp
 auto s = Sprite::create();
  s->setTextureRect(Rect(0, 0, 80, 80));
  s->setPosition(def.position.x*RAD, def.position.y*RAD);
  this->addChild(s);
  body->SetUserData(s);
```

调用update函数

```cpp
void CLASS::update(float dt)
{
  world->Step(dt, 8, 3);
  Sprite *s;
  for (b2Body *b = world->GetBodyList(); b!=nullptr; b=b->GetNext())
  {
	if (b->GetType()== b2BodyType::b2_dynamicBody)
	{
	  if (b->GetUserData())
	  {
		s=(Sprite*)b->GetUserData();
		s->setPosition(b->GetPosition().x*RAD, b->GetPosition().y*RAD);
	  }
	}
  }
```

## 创建一个Box2d世界

1. 创建一个物理世界

```cpp
#include "Box2D\Box2D.h"
```

利用`b2word`创建一个对象，并且指定这个物理世界中的加速度方向。

```cpp
word = new b2World(b2Vec2(0,-10));                        //指定物理世界的加速度
```

创建一个运动的物体

```
b2BodyDef def;
def.position = b2Vec2(10,10);
def.type = b2_dynamicBody;
word->CreateBody(&def);
```

之后为了能够显示出创建的这个物体的运动情况，在update中，可以通过一个循环来便利整个物理世界的物体列表，找到我们定义的这个物体就可以输出他在物理世界中自由落体的坐标变化

```
void HelloWorld::update(float dt)
{
	word->Step(dt, 8, 3);
	for(b2Body *b = word->GetBodyList(); b; b = b->GetNext())
	{
		if(b->GetType() == b2_dynamicBody)
		{
			log("x:%f, y:%f", b->GetPosition().x, b->GetPosition().y);
		}
	}
}
```

将创建的那个物体和sprite绑定在一起。

```
b2Body *b =  word->CreateBody(&def);
auto sprite = Sprite::create();
addChild(sprite);
sprite->setTextureRect(Rect(0,0,80,80));
b->SetUserData(sprite);
```

设置`box2d`模拟范围

```cpp
AppDelegate::applicationDidFinishLaunching();
glview->setDesignResolutionSize(800,600, ResolutionPolicy::SHOW_ALL);
```

设置初始位置

```cpp
s->setPosition(b->GetPosition().x * RATIO, b->GetPosition().y*RATIO);
def.position = b2Vec2(3,5);
```

不断更新图像

```cpp
void HelloWorld::update(float dt)
{
	word->Step(dt, 8, 3);
	Sprite *s;
	for(b2Body *b = word->GetBodyList(); b; b = b->GetNext())
	{
		if(b->GetType() == b2_dynamicBody)
		{
			if(b->GetUserData())
			{
				s = (Sprite*)b->GetUserData();
				s->setPosition(b->GetPosition().x * RATIO, b->GetPosition().y*RATIO);
			}
		}
	}
}
```

所以在update函数里面就要检查body对象是否绑定了图形，然后获取到他所绑定的图形，进行重新设置当前的图形坐标。



## 多边形编辑工具







 