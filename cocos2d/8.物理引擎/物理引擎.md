# c物理引擎

物理引擎能够模仿真实世界的运动规律,使精灵能够做出自由落体,抛物线运动,互相碰撞,反弹等效果

使用物理引擎还可以进行碰撞检测,往往自己写的碰撞检测没有优化而效率低下

## 核心概念

1. 世界(world)游戏中的物理世界
2. 物体(body)构成物理世界的基础,具有位置,旋转角度等特性,他们上面的任何两点之间的距离是完全不变的可以称为刚体(rigid body)
3. 形状 (Sharp)物体的形状,一个二维碰撞的集合结构
4. 接触点(Contact) 管理检测碰撞
5. 关节(joint) 把两个或多个物体固定到一起的约束

## 物体与精灵之间的关系

物理引擎本身不包括精灵,通常是通过程序使精灵与物理引擎进行连接



### cocos2d自带物理引擎

```c++
class Scene{
    //创建场景对象
    static Scene* createWithPhysics();

    //初始化具有物理引擎的的场景对象
    bool initWithPhysics();

    //增加解答到物理世界
    void addChildToPhysicsWorld(Node *child);
    
    //添加节点到物理引擎世界
    bool addchildToPhysics();
    
    //获取物理世界对象
    PhysicsWorld *getPhysicsWorld();

};
```

## 物理引擎常用类

```cpp
//封装了物理世界引擎
class PhysicsWorld;

//封装物理引擎形状
class PhysiscBody;

//物理引擎碰撞
class PhysiscSharp;

//碰撞监听类
class EventListenerPhysicsContact;

//封装物理引擎关节
class PhysicsJoit;
```

### 形状类

```c++
//形状类
class PhysicsSharp{
    public:
    //画圆
    class PhysicsShapeCircle;	
    //多边形
    class PhysicsShapePolygon;
    //有边的线段
    class PhysicsShapeEdgeBox
     //有边的矩形盒子
    class PhysicsShapeEdgeBox;
    //有边的多边形
    class PhysicsShapeEdgePolygon;
 	   
}
```

### 碰撞检测事件属性

通过`EventListenerPhysicsContact` 中检测碰撞事件响应属性



```cpp
//开始接触响应事件,只调用一次
function<bool PhysicsContact& contact> onContactBegin;

//持续接触监听事件,返回false的情况下不调用onContactPostSolve
function<bool PhysicsContact& contact, PhiscsContactPreSolve &solve> onContactPreSolve;

//持续接触监听事件,调用完onContactPreSolve后调用
function<bool PhysicsContact& contact, PhiscsContactPreSolve &solve> onContactPostSolve;

//分离时响应,只调用一次
function<bool PhysicsContact& contact> onContactSeperate;
```

## 物理引擎和精灵的关系

物理引擎和精灵是相互之间独立的,精灵不会自动地跟着物理引擎做物理运动,而是通过和编写代码将物体和精灵连接起来,同步他们的状态.

例:

```cpp
void HelloScene::updata(float dt){
    float timeStep=0.03f;
}
```



# 物理引擎

## 创建物理引擎

引入一个头文件

```cpp
#include "Box2D/Box2D.h"
```

创建一个世界并指定它的加速度方向

```cpp
world = new b2World(b2Vec2(0, -10));
```

创建一个运动的物体

```cpp
//定义运动的物体
b2BodyDef def;
//运动的类型
def.type = b2BodyType::b2_dynamicBody;
//运动的位置
def.position = b2Vec2(4, 5);
//创建物体
b2Body* body= world->CreateBody(&def);
```

然后让这个物体和sprite绑定在一起

```cpp
 auto s = Sprite::create();
  s->setTextureRect(Rect(0, 0, 80, 80));
  s->setPosition(def.position.x*RAD, def.position.y*RAD);
  this->addChild(s);
  body->SetUserData(s);
```

调用update函数

```cpp
void CLASS::update(float dt)
{
  world->Step(dt, 8, 3);
  Sprite *s;
  for (b2Body *b = world->GetBodyList(); b!=nullptr; b=b->GetNext())
  {
	if (b->GetType()== b2BodyType::b2_dynamicBody)
	{
	  if (b->GetUserData())
	  {
		s=(Sprite*)b->GetUserData();
		s->setPosition(b->GetPosition().x*RAD, b->GetPosition().y*RAD);
	  }
	}
  }
```







# box2d引擎

常用的属性

- 世界(b2World)
- 物体(b2Body)
- 形状(b2Shape)
- 夹具(b2Fixture)讲形状固定在物体上的装置，有了形状才能具有碰撞等物理特性
- 关节(b2Fixture) 

## 使用Box2d引擎

步骤

1. 创建物理世界
2. 指定世界边界
3. 创建世界中的物体
4. 创建形状
5. 创建夹具
6. 使用夹具固定到物体上
7. 连接精灵和物体
8. 碰撞检测

## 添加Box2D









## Box2d 引擎

物理引擎的底层是box2d引擎和**Chipmunk引擎**



### 核心概念

1. 世界b2World  物理引擎中的物理世界
2. 物体b2Body,物理世界中的物体
3. 形状(b2Shape),物体中的形状
4. 夹具(b2Joint) 将形状固定在物体的装置上
5. 关节(b2Fixture) 引擎中的关节

### 使用步骤





# c物理引擎

物理引擎能够模仿真实世界的运动规律,使精灵能够做出自由落体,抛物线运动,互相碰撞,反弹等效果

使用物理引擎还可以进行碰撞检测,往往自己写的碰撞检测没有优化而效率低下

## 核心概念

1. 世界(world)游戏中的物理世界
2. 物体(body)构成物理世界的基础,具有位置,旋转角度等特性,他们上面的任何两点之间的距离是完全不变的可以称为刚体(rigid body)
3. 形状 (Sharp)物体的形状,一个二维碰撞的集合结构
4. 接触点(Contact) 管理检测碰撞
5. 关节(joint) 把两个或多个物体固定到一起的约束

## 物体与精灵之间的关系

物理引擎本身不包括精灵,通常是通过程序使精灵与物理引擎进行连接



### cocos2d自带物理引擎

```c++
class Scene{
    //创建场景对象
    static Scene* createWithPhysics();

    //初始化具有物理引擎的的场景对象
    bool initWithPhysics();

    //增加解答到物理世界
    void addChildToPhysicsWorld(Node *child);
    
    //添加节点到物理引擎世界
    bool addchildToPhysics();
    
    //获取物理世界对象
    PhysicsWorld *getPhysicsWorld();

};
```

## 物理引擎常用类

```cpp
//封装了物理世界引擎
class PhysicsWorld;

//封装物理引擎形状
class PhysiscBody;

//物理引擎碰撞
class PhysiscSharp;

//碰撞监听类
class EventListenerPhysicsContact;

//封装物理引擎关节
class PhysicsJoit;
```

### 形状类

```c++
//形状类
class PhysicsSharp{
    public:
    //画圆
    class PhysicsShapeCircle;	
    //多边形
    class PhysicsShapePolygon;
    //有边的线段
    class PhysicsShapeEdgeBox
     //有边的矩形盒子
    class PhysicsShapeEdgeBox;
    //有边的多边形
    class PhysicsShapeEdgePolygon;
 	   
}
```

### 碰撞检测事件属性

通过`EventListenerPhysicsContact` 中检测碰撞事件响应属性



```cpp
//开始接触响应事件,只调用一次
function<bool PhysicsContact& contact> onContactBegin;

//持续接触监听事件,返回false的情况下不调用onContactPostSolve
function<bool PhysicsContact& contact, PhiscsContactPreSolve &solve> onContactPreSolve;

//持续接触监听事件,调用完onContactPreSolve后调用
function<bool PhysicsContact& contact, PhiscsContactPreSolve &solve> onContactPostSolve;

//分离时响应,只调用一次
function<bool PhysicsContact& contact> onContactSeperate;
```

## 物理引擎和精灵的关系

物理引擎和精灵是相互之间独立的,精灵不会自动地跟着物理引擎做物理运动,而是通过和编写代码将物体和精灵连接起来,同步他们的状态.

例:

```cpp
void HelloScene::updata(float dt){
    float timeStep=0.03f;
}
```



# 物理引擎

## 创建物理引擎

引入一个头文件

```cpp
#include "Box2D/Box2D.h"
```

创建一个世界并指定它的加速度方向

```cpp
world = new b2World(b2Vec2(0, -10));
```

创建一个运动的物体

```cpp
//定义运动的物体
b2BodyDef def;
//运动的类型
def.type = b2BodyType::b2_dynamicBody;
//运动的位置
def.position = b2Vec2(4, 5);
//创建物体
b2Body* body= world->CreateBody(&def);
```

然后让这个物体和sprite绑定在一起

```cpp
 auto s = Sprite::create();
  s->setTextureRect(Rect(0, 0, 80, 80));
  s->setPosition(def.position.x*RAD, def.position.y*RAD);
  this->addChild(s);
  body->SetUserData(s);
```

调用update函数

```cpp
void CLASS::update(float dt)
{
  world->Step(dt, 8, 3);
  Sprite *s;
  for (b2Body *b = world->GetBodyList(); b!=nullptr; b=b->GetNext())
  {
	if (b->GetType()== b2BodyType::b2_dynamicBody)
	{
	  if (b->GetUserData())
	  {
		s=(Sprite*)b->GetUserData();
		s->setPosition(b->GetPosition().x*RAD, b->GetPosition().y*RAD);
	  }
	}
  }
```







# box2d引擎

常用的属性

- 世界(b2World)
- 物体(b2Body)
- 形状(b2Shape)
- 夹具(b2Fixture)讲形状固定在物体上的装置，有了形状才能具有碰撞等物理特性
- 关节(b2Fixture) 

## 使用Box2d引擎

步骤

1. 创建物理世界
2. 指定世界边界
3. 创建世界中的物体
4. 创建形状
5. 创建夹具
6. 使用夹具固定到物体上
7. 连接精灵和物体
8. 碰撞检测

## 添加Box2D









## Box2d 引擎

物理引擎的底层是box2d引擎和**Chipmunk引擎**



### 核心概念

1. 世界b2World  物理引擎中的物理世界
2. 物体b2Body,物理世界中的物体
3. 形状(b2Shape),物体中的形状
4. 夹具(b2Joint) 将形状固定在物体的装置上
5. 关节(b2Fixture) 引擎中的关节

### 使用步骤







