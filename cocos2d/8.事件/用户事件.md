# 用户事件

事件的重要三个概念

+ 事件
+ 事件源
+ 事件处理着



## 事件

事件类`Event`,子类主要有

1. `EventTouch`(触摸事件)
2. `EventMouse`(鼠标事件)
3. `EventKeyBoard`(键盘事件)
4. `EventAcceleration`(加速度事件)

## 事件源

事件源是Cocos2d-x中的精灵层,菜单等节点对象\

### 事件处理

`EventListener`中的事件处理着是事件监听类,主要功能有

+ EventListenerTouchOneByOne(单点触摸事件)
+ EventListenerTouchAllAtOnce(多点触摸事件监听器)
+ EventListenerMouse(鼠标事件监听器)
+ EventListenerAcceleration(加速度监听事件)
+ EventListenerCustom(自定义监听事件)

## 事件处理机制

事件通过与用户的输入设备进行交互,当用户执行某个输入事件时就会触发事件,然后程序根据触发的时间执行相应的函数和代码

## 事件分发器

监听器与事件有对应关系

`EventDispatcher` 类采用单例模式的方式实现,注册事件监听器到事件分发器函数如下

```cpp
//通过单例模式获取事件分发器对象
Director::getInstance()->getEventDispatcher();

class  EventDispatcher{
    //注册事件监听器
    void addEventListenerWithFixedPriority(EventListener *listener,Node* n);

    //注销指定的事件监听器
    void removeEventListener(EventListener *listener);

    //注销自定义事件监听器
    void removeCustomEventListener(EventListener *listener);

    //注销自定义事件
    void removeAllEventListeners();

    //注销所有事件
    void removeAllEventListeners();
}
```

### 移除事件监听

通常在`onExit`函数中调用,在节点生命周期结束后调用

```
_eventDispatcher->removeEventListener(listener);
```



### 触摸事件

触摸事件有一下方法

+ 按下
+ 移动
+ 抬起
+ 取消

单点触摸事件

`EventListenerTouchOnceByOnce` 事件

```c++
//触摸时调用
class EventListenerTouchOnceByOnce 
{
    //开始触摸按键,返回true的话就会继续执行后面的事件
    bool std::function<bool(Touch* Event*)> onTouchBegan;
    //移动
    void std::function<bool(Touch* Event*)> onTouchMoved;

    //手指离开时调用
    void std::function<bool(Touch* Event*)> onTouchEnded;

    //单点触摸被取消时调用
    void std::function<bool(Touch* Event*)> onTouchCancelled;
};
```

#### 触摸事件移动操作



### 多点事件

EventListenerTouchAllAtOnce 中触摸响应属性

```c++
//多点鼠标触摸事件
class EventListenerTouchAllAtOnce {
    //多点触摸响应事件
    std::function<bool(Touch* Event*)> onTouchesBegan;

    //多手指移动事件    
    std::function<bool(Touch* Event*)> onTouchesMoved;

    //多手指离开事件
    std::function<bool(Touch* Event*)> onTouchesEnded;

    //多手指事件取消
    std::function<bool(Touch* Event*)> onTouchesCancelled;
};
```

### 重力感应事件(加速度传感器)

现在一些移动设备配备有加速度传感器，我们可以通过监听它的事件获取各方向的加速度。

可以设想要完成一个游戏情景：通过来回移动手机，平衡小球在手机中的位置。这种场景的完成，就需要监听加速度传感器事件。

```cpp
//使用加速度传感器,需要先启用
Device::setAccelerometerEnabled(true);
```

### 键盘事件

`EventListenerKeyboard` 事件

```cpp
class EventListenerKeyboard{
    //键盘按下
    void onKeyPressed (EventKeyBoard::KeyCode code,Event *e);
    按下状态的按键被放开时
    void onKeyRelease(EventKeyBoard::KeyCode code,Event *e);
};
```



## 添加事件

使用`CC_CALLBACK_2`进行事件绑定

````cpp
//添加事件管理对象
auto dispatcher = Director::getInstance()->getEventDispatcher();

//创建事件
auto listener = EventListenerxxxx::create();

//绑定事件回调
listener->addxxxx=CC_CALLBACK_2(类名::回调函数,监听目标);

//事件
Director::getInstance()->getEventDispatcher(); 

//系统实现好的系统分发器对象与通过director对象获取一致
_eventDispatcher->
````

### 

## 自定义事件

```cpp
class EventListenerCustom{
    EventListenerCustom* create(string name,Schedule);
	
}
```

定义一个自定义监听器,并预设了响应方法

```cpp

_listener = EventListenerCustom::create("game_custom_event1", [=](EventCustom* event){
std::string str("Custom event 1 received, ");
char* buf = static_cast<char*>(event->getUserData());
str += buf;
str += " times";
statusLabel->setString(str.c_str());
});
_eventDispatcher->addEventListenerWithSceneGraphPriority(_listener, this);
```

手动分发响应事件

```cpp

static int count = 0;
++count;
char* buf[10];
sprintf(buf, "%d", count);
EventCustom event("game_custom_event1");
//设置了 UserData 数据
event.setUserData(buf);
//响应函数中可以获取到事件分发时设置的 UserData 完成数据处理
_eventDispatcher->dispatchEvent(&event);
```

## 注册事件监听

需要注意的是，在添加到多个对象时，需要使用 **clone()** 方法。否则的话就会出现引用错误

```cpp
// Add listener
_eventDispatcher->addEventListenerWithSceneGraphPriority(listener1,
                                                         sprite1);
// Add the same listener to multiple objects.
_eventDispatcher->addEventListenerWithSceneGraphPriority(listener1->clone(),
                                                         sprite2);
_eventDispatcher->addEventListenerWithSceneGraphPriority(listener1->clone(),
                                                         sprite3);
```

