# 多线程

1. 多线程`Qthread`
2. 多线程控制
3. 互斥量`QMutex`
4. 信号量`QSemaphore`
5. 线程的等待和唤醒`QWaitConditon`

## 线程 `Qthread`

线程：
通常情况下，应用程序都是在一个线程中执行操作。

但是，当调用一个耗时操作(例如，大批量I/O或大量矩阵变换等CPU密集操作)时，用户界面常常会冻结。

而使用多线程可解决这一问题。

### 线程优势:
1. 提高应用程序的响应速度

（这对于开发图形界面的程序尤为重要，当一个操作耗时很长时，整个系统都会等待这个操作，程序就不能响应键盘、鼠标、菜单等的操作，而使用多线程技术可将耗时长的操作置于一个新的线程，从而避免以上问题）

2. 使多cpu系统更加有效。
（当线程数大于CPU数目时，操作系统可以调度不同的线程运行于不同的CPU上）

3. 改善程序结构.
（一个既长又复杂的进程可以考虑为多个线程，成为独立或单独立的运行部分，这样有利于代码的理解和维护）

### 多线程程序有几个特征:

（一个既长又复杂的进程可以考虑为多个线程，成为独立或单独立的运行部分，这样有利于代码的理解和维护）
1. 多线程的行为无法预期，当多次执行上述程序时，每一次的运行结果都可能不同

2. 多线程的执行顺序无法保证，它与操作系统的调度策略和线程优先级等因素有关

3. 多线程的切换可能发生在任何时刻、任何地点。

4. 多线程对代码的敏感度高，因此对代码的细微修改都可能产生意想不到的结果

基于以上这些特点，为了有效地使用线程，开发人员必须对其进行控制

### 多线程控制

介绍QT线程同步互斥控制的基本方法。
线程之间存在着互相制约的关系，具有可分为互斥和同步这两种关系

实现线程的互斥与同步常使用的类有QMutex、QMutexLocker、QReadWriteLocker、QRead Locker、QWriteLocker、QSempaphore和QWaitCondition

```cpp
class key{
public:
    key(){key=0;}
    int creatkey(){++key;return key;}
    int value()const{return key;}
private:
    int key; 
};
```

这里实现生成从0开始递增并且不允许重复的值的key类
在多线程环境下，这个类是不安全的，因为存在多个线程同时修改私有成员key，其结果是不可预知的

虽然key产生主键的函数creatkey()只有一条语句执行修改成员变量key的值，但是C++的”++”操作符并不是原子操作，通常编译后，它将被展开成为以下三条机器命令：
将变量值载入寄存器
将寄存器中的值加1 
将寄存器中的值写会主存
假设当前的key的值为0，如果线程1和线程2同时将0值载入寄存器，执行加1操作并将加1后的值写会主存，则结果是两个线程的执行结果将互相覆盖，实际上仅进行了一次加1操作，此时的key的值为1

## 互斥量 `QMetux`

为了保证类key在多线程环境下正确执行，上面的三条机器指令必须串行执行且不允许中途被打断(原子操作)，即线程1在线程2（或线程2在线程1）之前完整执行上述三条机器指令
	
实际上，私有变量key是一个临界资源（Critical Resoure，CR）。临界资源一次仅允许被一个线程使用，它可以是一块内存、一个数据结构、一个文件或者任何其他具有排他性使用的东西。在程序中，通常竞争使用临界，这些必须互斥执行的代码段称为”临界资区” Critical Section，CS),临界区（代码段）实施对临界资源的操作，为了阻止问题的产生，一次只能有一个线程进入临界区。通常有相关的机制或方法在程序中加上”进入”或”离开”临界区等操作。如果一个线程已经进入某个临界区，则另一个线程觉不允许在此刻进入同一个临界区

互斥量可通过QMutex或者QMutexLocker类来实现

### QMutex类

Mutex类是对互斥量的处理。它被用来保护一段临界区代码，即每次只允许一个线程访问这段代码。
QMutex 类的lock()函数用于锁住互斥量。如果互斥量处于解锁状态，则当前线程就会立即抓住并锁定它，否则当前线程就会被阻塞，直到持有这个互斥量的线程对它解锁。

线程调用lock()函数后就会持有这个线程这个互斥量，直到调用unlock()操作为止.

Mutex类还提供了一个tryLock()函数，如果互斥量已被锁定，则立即返回。

```cpp
class key{
public:
    key(){key=0;}
    int creatkey(){ mutex.lock();++key;return key;mutex.unlock;}
    int value()const{return key;}
private:
int key;
QMutex mutex; 
};
```

在上述的代码段中，虽然`creatkey()`函数中使用`mutex`进行了互斥操作，但是`unlock()`操作却不得不在`return`之后，从而导致`unlock()`操作永远无法执行，同样，`value()`函数也存在这个问题

### QMutexLocker类

 Qt提供的QMutexLocker类可以简化互斥量的处理，它在构造函数中接收一个QMutex对象作为参数并将其锁定，在构造函数中解锁这个互斥量，这样就解决了以上问题

## 信号量

信号量可以理解为对互斥量功能的扩充，互斥量只能锁定一次而信号量可以获取多次，它可以用来保护一定数量的同种资源。信号量的典型用例是控制生产者和消费者之间共享的环形缓冲区

生产者/消费者实中对同步的需求有两种：
1. 如果生产者过快地生产数据，将会覆盖消费者还没有读取的数据

2. 如果消费者过快的读取数据，将越过生产者并且读取到一些过期数据

针对以上问题，可以有两种解决方法：
1. 首先使生产者填满整个缓冲区，然后等待消费者读取整个缓冲区，这是一种比较笨拙的方法

2. 使生产者和消费者线程同时分别操作缓冲区的不同部分，这是一种比较高效的方法

## 线程等待与唤醒

对生产者和消费者问题的另一个解决方法是使用QWaitCondition类，允许线程在一定条件下唤醒其他线程

### 多线程应用


