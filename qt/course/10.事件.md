# 事件

1. 鼠标事件`QMouseEvent`
2. 键盘事件`QKeyEvent`
3. 事件过滤`eventFilter`

 QT程序是事件驱动的, 程序的每个动作都是由内部某个事件所触发。QT事件的发生和处理成为程序运行的主线，存在于程序整个生命周期。

  QT将系统产生的消息转化为QT事件，QT事件被封装为对象，所有的QT事件均继承抽象类QEvent，用于描述程序内部或外部发生的动作，任意的QObject对象都具备处理QT事件的能力。

### 事件处理：

 通过鼠标事件、键盘事件和事件过滤的三个实例介绍事件处理的实现

## 鼠标事件 `QMouseEvent`

头文件 <QMouseEvent>

### 获取坐标位置

```cpp
globalPos() //获取全局位置
this*->frameGeometry().topLeft();//获取窗口左上角坐标
```

### 鼠标事件

```cpp
protected:
virtual void mousePressEvent(QMouseEvent *event);				//鼠标按下事件
virtual void mouseReleaseEvent(QMouseEvent *event);				//鼠标释放事件
virtual void mouseDoubleClickEvent(QMouseEvent *event);			//鼠标双击事件
virtual void wheelEvent(QWheelEvent *event);					//滚轮事件
```

鼠标重写事件

```cpp 
public:
void Widget::mouseMoveEvent(QMouseEvent *event)
{
    //event鼠标按下记录x坐标y坐标
    int x=event->x();
    int y=event->y();
    qDebug()<<x<<" "<<y<<endl;
}
```

**设置鼠标穿透**

```cpp
label->setAttribute(Qt::WA_TransparentForMouseEvents);
```

**打印窗口坐标位置**

```cpp
qDebug()<<e->pos();
```



### 鼠标点击按钮

```cpp
void Widget::mousePressEvent(QMouseEvent *event)
{
     if(event‐>button() == Qt::LeftButton)
     {
         qDebug() << QStringLiteral("鼠标左键按下");
     }
     else if(event‐>button() == Qt::RightButton)
     {
         qDebug() << QStringLiteral("鼠标右键键按下");
     }
     else if(event‐>button() == Qt::MiddleButton)
     {
         qDebug() << QStringLiteral("鼠标中键键按下");
     }
 }
 
 void Widget::wheelEvent(QWheelEvent *event)
 {
     if(event‐>delta() > 0)
     {
         qDebug()<<QStringLiteral("滚轮往前推...");
     }
     else
     {
         qDebug()<<QStringLiteral("滚轮往后推...");
     }
}
```



鼠标事件是`QMouseEvent`类里面的鼠标事件。

鼠标事件包括鼠标移动，鼠标键按下、松开、点击、双击等

通常进行重定义部件的鼠标事件处理函数来实现自定义的内容操作。

### 鼠标按下事件

```cpp
//这个是鼠标按下的时候调用该函数
 void mousePressEvent(QMouseEvent *event); 

//这个是鼠标松开按键的时候调用
 void mouseReleaseEvent(QMouseEvent *event); 

//这个是鼠标双击的时候调用
void mouseDoubleClickEvent(QMouseEvent *event); 

//这个是鼠标按下状态中，移动的时候调用
void mouseMoveEvent(QMouseEvent *event);
```

### 鼠标滚轮事件

鼠标滚轮操作是利用QWheelEvent实现滚轮事件

当鼠标指针定位于一个窗口界面之上时，滚动鼠标滚轮会产生一系列QWheelEvent事件，这些事件被传送给鼠标指针所在的父窗口，如果此窗口不处理此事件，则该鼠标事件会传送给具有输入焦点的窗口。
滚轮滚动的距离可以用函数delta()计算，函数pos()和globalPos()可返回发生该鼠标滚轮事件时鼠标指针的当前位置。

一个QWheelEvent事件包含一些指定的接受标志用于指出该事件是否会被接收和处理，如果不处理该事件可以调用ignore()，这样可以保证该事件会被传送给鼠标指针所在的父窗口。
而函数QWidget::setEnabled()则可以用于禁止或允许一个窗口接收鼠标和键盘事件。
事件处理函数QWidget::wheelEvent()被用于接收鼠标滚轮事件，一般在处理QWheelEvent时需要实现该函数。

```cpp
//这个是鼠标上下滚轮的时候会调用
void wheelEvent(QWheelEvent*event); 
```

## 键盘事件

### 声明

Qt键盘事件属于Qt事件系统,所以事件系统中所有规则对按键事件都有效。
要对按键进行响应，我们只需要直接重载两个方法即可

```cpp
virtual void keyPressEvent(QKeyEvent *event);//按键按下事件

virtual void keyReleaseEvent(QKeyEvent *event);//按键释放
```

### 实现

```cpp
//按键按下事件
void Widget::keyPressEvent(QKeyEvent *event)
{
    //当键盘按下T进入
    if(event‐>key() == Qt::Key_T)
    {
        qDebug() << "Key_T is pressed";
    }
    //当键盘按下Z进入
    else if(event‐>key() == Qt::Key_Z)
    {
        qDebug() << "Key_Z is pressed";
    }
	//组合键盘	
    if(event->modifiers()==Qt::ControlModifier)//第一次判断是否按下CTRL
    {   
        if(event->key()==Qt::Key_A)//判断是否按下T
        {
            qDebug() << "Ctrl + A is pressed";
        }
    }
}
```

 注意：

对我们不处理的事件，要调用父类的相应事件处理函数。

如果widget当前没有焦点，考虑到事件转发：如果其子widget有焦点，那么该widget未处理的键盘事件将被转发过来。

有时输入焦点不在任何窗口中。这种情况发生在所有程序都是最小化的时候。这时，Windows将继续向活动窗口发送键盘消息，但是这些消息与发送给非最小化的活动窗口的键盘消息有不同的形式。

 QKeyEvent
在windows下，与键盘事件有关的有8个消息：

对产生可显示字符的按键组合，Windows不仅给程序发送按键消息，而且还发送字符消息
有些键不产生字符，这些键包括shift键、功能键、光标移动键和特殊字符键如Insert和Delete。对于这些键，Windows只产生按键消息。

这些消息在Qt中只体现在QKeyEvent中。

对字符，可通过 QKeyEvent::text() 获得
其他键，QKeyEvent::key() 获得一个键值

focus
一个拥有焦点(focus)的QWidget才可以接受键盘事件。有输入焦点的窗口是活动窗口或活动窗口子窗口或子子窗口 
焦点移动的方式有以下几种：
按下Tab或Shift+Tab
注意：文本编译器（一般需要插入Tab），或者WebView(需要Tab来移动超链接焦点) 等
Qt中，需要输入Tab的地方可以用 Ctrl+Tab 或 Ctrl+Shift+Tab 替代。

点击一个QWidget
建议：只对接受文本输入的Widget启用该功能
    
按下键盘的快捷键
        QLabel::setBuddy(), QGroupBox,以及 QTabBar 支持

    使用鼠标滚轮
    
    用户移动焦点
        程序将决定被设置focus的Widget的哪一个子Widget获得焦点

注意：如果一个 Widget 已经 grabKeyboard，所有键盘事件将发送到该Widget而不是获得焦点的Widget


focusPolicy
 一个QWidget获得焦点的方式受 focusPolicy 控制

Qt::TabFocus
    通过Tab键获得焦点
Qt::ClickFocus
    通过被单击获得焦点
Qt::StrongFocus
    可通过上面两种方式获得焦点
Qt::NoFocus
    不能通过上两种方式获得焦点(默认值),setFocus仍可使其获得焦点

### 事件过滤

Qt的事件模型中提供的事件过滤器功能使得一个QObject对象可以监视另一个QObject对象中的事件，通过在一个QObject对象中安装事件过滤器，可以在时间到达该对象前捕获事件，从而起到监视该对象事件的效果

Qt中的事件传递顺序

在Qt中，当一个事件发生时
(例如鼠标点击或某个键盘上的
按键按下),其传递顺序如图所示。

从这个图可以看出，事件过滤器首先获
得事件，其次才是部件的 event 函数，
最后是部件的事件处理函数。


与事件过滤器相关的函数

事件过滤器由QObject类中的两个函数来实现。一个是 installEventFilter，它负责在相应部件上安装事件过滤器，其声明为：

```cpp
void QObject::installEventFilter(QObject *filterObj);
```

其中，filterObj参数表示要在其上实现事件过滤器函数的部件。请注意，如果我们在一个部件安装了事件过滤器，一般在其父控件上实现事件过滤器函数。

