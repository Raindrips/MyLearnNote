#include "widget.h"
#include "ui_widget.h"
#include <QDebug>

Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
{
    ui->setupUi(this);
    connect(&rtTimer, SIGNAL(timeout()), this, SLOT(rtTimerOutSlot()));
    connect(this, SIGNAL(luckStartSignal()), this, SLOT(luckStartSlot()));
    //rtTimer.start(1000);
    //qDebug() << ByteArrayToHexStr("中");
}

Widget::~Widget()
{
    delete ui;
}

////字节数组转16进制字符串
//QString Widget::ByteArrayToHexStr(QByteArray data)
//{
//   QString temp = "";
//   QString hex = data.toHex();
//   for (int i = 0; i < hex.length(); i = i + 2) {
//        temp += hex.mid(i, 2) + " ";
//   }
//   return temp.trimmed().toUpper();
//}

void Widget::rtTimerOutSlot()
{
    rtAngle++;
    //设置4档速度  4AT
    if((rtAngle - randNumber) == 90)
    {   //if(randNumber = 427 )  rtAngle = 427 + 90
        rtTimer.setInterval(10);   //第一次降低速度
        qDebug() << "rtAngle90 :" << rtAngle;
    }
    else if((rtAngle - randNumber) == 180)
    {   //427 + 180
        rtTimer.setInterval(15);  //第二次降速
        qDebug() << "rtAngle180 :" << rtAngle;

    }
    else if((rtAngle - randNumber) == 270)
    {
        rtTimer.setInterval(30);  //第三次降速
        qDebug() << "rtAngle270 :" << rtAngle;

    }
    else if((rtAngle - randNumber) == 360)
    {
        rtAngle-- ;      //让速度慢慢降为0  rtAngle = 0时就转不动了
        rtTimer.stop();  //停止计时 界面更新事件
        qDebug() << "rtAngle360 :" << rtAngle;
    }
    update();
}

void Widget::paintEvent(QPaintEvent *event)
{
    //图片
    rotaionPainter.begin(this);
    //将画板坐标从窗口左上角转到窗口中心坐标（200，200）
    rotaionPainter.translate(200, 200);
    //旋转画板坐标系
    rotaionPainter.rotate(rtAngle);
    rotaionPainter.drawPixmap(-200, -200,
                              400, 400,
                              QPixmap(":/image/png/luck.png"));
    rotaionPainter.end();

    //指针
    pointPainter.begin(this);
    pointPainter.translate(200, 200);
    static const QPoint point[4] = {QPoint(0, 18), QPoint(20, 0),
                                   QPoint(0, -100), QPoint(-20, 0)};
    pointPainter.setBrush(QColor(Qt::blue));
    pointPainter.drawPolygon(point, 4);

    //铆钉
    static const QRect rectanle(-7, -7, 14, 18);
    pointPainter.setBrush(QColor(Qt::darkYellow));
    pointPainter.drawEllipse(rectanle);
    //结束绘图
    pointPainter.end();

    //画轨迹
    if(mouseFlag){
        pointPainter.begin(this);
        //pointPainter.drawLine(lastPoint, endPoint);
        for(int i=0;i<m_points.size()-1;i++)
        {
            QPoint & p1=m_points[i];
            QPoint & p2=m_points[i+1];
            pointPainter.drawLine(m_points[i], m_points[i+1]);
        }
        pointPainter.end();
    }
}

void Widget::mousePressEvent(QMouseEvent *event)
{
    if(event->button() == Qt::LeftButton)
    {
        if(event->pos().x() > 180 && event->pos().x() < 220
           &&event->pos().y() > 130 && event->pos().y() < 216)
        {
            //qDebug() << "point event";
            emit luckStartSignal();
        }
        lastPoint = event->pos();
        mouseFlag = true;
    }
}

void Widget::mouseReleaseEvent(QMouseEvent *event)
{
    mouseFlag = false;
    //lastPoint = endPoint;
}
void Widget::mouseMoveEvent(QMouseEvent *event)
{
    if(mouseFlag){
        endPoint = event->pos();
        m_points.append(endPoint);
        update();
    }
}

void Widget::luckStartSlot()
{
    /* 撒一把随机数 */
    rtAngle = 1;
    qsrand(QTime(0, 0, 0).secsTo(QTime::currentTime()));
    randNumber = qrand()%360 + 180;
    qDebug() << "randNumber :" << randNumber;
    rtTimer.start(5);
}
